/* Generated by Frama-C */
struct struct_intlist__xP {
   struct intlist_ *struct_intlist__xM ;
};
struct char_P {
   char char_M ;
};
struct void_P {
   
};
/*@ behavior default:
      assigns \nothing;  */
void free(struct char_P *ptr ) ;
typedef unsigned int size_t;
struct intlist_;
typedef struct intlist_ *intlist;
struct intlist_ {
   int data ;
   intlist next ;
};
/*@ behavior default:
      assigns \at(\result,Post) \from __size;  */
extern  __attribute__((__nothrow__)) struct char_P *malloc(size_t __size )  __attribute__((
__malloc__)) ;
/*@
predicate reach{L}(intlist from, intlist to) =
  ((from ≡ to) ∨ (\valid(from) ∧ reach(from->next, to)));
 */
/*@ predicate acyclic{L}(intlist l) = reach{L}(l, \null);
 */
/*@
predicate disjoint{L}(intlist l1, intlist l2) =
  ¬((∃ struct intlist_ *l_0; (reach{L}(l1, l_0) ∧ reach{L}(l2, l_0))));
 */
/*@
predicate disjoint3{L}(intlist l1_0, intlist l2_0, intlist l3) =
  ((disjoint{L}(l1_0, l2_0) ∧ disjoint{L}(l2_0, l3)) ∧
  disjoint{L}(l1_0, l3));
 */
/*@ logic ℤ len(intlist ptr) = ptr≡\null? 0: 1+len(ptr->next);
 */
intlist fold_clone(intlist x_1 ) ;
void fold_split(intlist x_0 , int v , struct struct_intlist__xP *l ,
                struct struct_intlist__xP *u ) ;
intlist fold2_concat(intlist x , intlist y ) ;
/*@ requires //id:268
             acyclic{Here}(a);
    behavior default:
        */
intlist quicksort(intlist a ) 
{
  struct struct_intlist__xP *left ;
  struct struct_intlist__xP *right ;
  intlist pivot ;
  intlist res ;
  intlist start ;
  intlist tmp ;
  int d ;
  intlist tmp_1 ;
  intlist tmp_2 ;
  /*sid:2*/
  if (a == (struct char_P *)0) { /*sid:3*/ res = fold_clone(a); }
  else {
    /*sid:4*/
    start = a->next;
    /*sid:6*/
    if (start == (struct char_P *)0) { /*sid:7*/ res = fold_clone(a); }
    else {
      /*sid:8*/
      d = a->data;
      /*sid:9*/
      pivot = (intlist )malloc(sizeof(struct intlist_ ));
      /*sid:10*/
      pivot->next = (struct intlist_ *)((struct char_P *)0);
      /*sid:11*/
      pivot->data = d;
      /*sid:12*/
      fold_split(start,d,left,right);
      /*sid:13*/
      start = (struct intlist_ *)((struct char_P *)0);
      /*sid:14*/
      tmp = quicksort(left->struct_intlist__xM);
      /*sid:15*/
      left->struct_intlist__xM = (struct intlist_ *)((struct char_P *)0);
      /*sid:16*/
      left->struct_intlist__xM = tmp;
      /*sid:17*/
      tmp = (struct intlist_ *)((struct char_P *)0);
      /*sid:18*/
      tmp = quicksort(right->struct_intlist__xM);
      /*sid:19*/
      right->struct_intlist__xM = (struct intlist_ *)((struct char_P *)0);
      /*sid:20*/
      right->struct_intlist__xM = tmp;
      /*sid:21*/
      tmp = (struct intlist_ *)((struct char_P *)0);
      /*sid:22*/
      tmp = fold2_concat(left->struct_intlist__xM,pivot);
      /*sid:23*/
      res = fold2_concat(tmp,right->struct_intlist__xM);
      /*sid:24*/
      { /*undefined sequence*/ 
        /*sid:25*/
        pivot = (struct intlist_ *)((struct char_P *)0);
        /*effects: pivot <- */
        /*sid:26*/
        tmp_2 = pivot;
        /*effects:  <- */
        /*sid:27*/
        right->struct_intlist__xM = tmp_2;
        /*effects: right->struct_intlist__xM <- tmp_2, right*/
        /*sid:28*/
        tmp_1 = tmp_2;
        /*effects:  <- */
        /*sid:29*/
        left->struct_intlist__xM = tmp_1;
        /*effects: left->struct_intlist__xM <- tmp_1, left*/
        /*sid:30*/
        tmp = tmp_1;
        /*effects: tmp <- */
      }
    }
  }
  /*sid:31*/
  return (res);
}

/*@ requires //id:201
             ((acyclic{Here}(x) ∧ acyclic{Here}(y)) ∧
             disjoint{Here}(x, y));
    behavior default:
      
  
*/
intlist fold2_concat(intlist x , intlist y ) 
{
  intlist r ;
  intlist z ;
  intlist zi ;
  intlist tmp_0 ;
  intlist li ;
  /*sid:32*/
  { /*undefined sequence*/ 
    /*sid:33*/
    li = (struct intlist_ *)((struct char_P *)0);
    /*effects: li <- */
    /*sid:34*/
    tmp_0 = li;
    /*effects: tmp_0 <- */
    /*sid:35*/
    zi = tmp_0;
    /*effects: zi <- */
    /*sid:36*/
    z = zi;
    /*effects: z <- */
    /*sid:37*/
    r = z;
    /*effects: r <- */
  }
  /*sid:38*/
  li = x;
  /*sid:39*/
  while (li != (struct char_P *)0) {
    /*sid:43*/
    zi = (intlist )malloc(sizeof(struct intlist_ ));
    /*sid:44*/
    zi->data = li->data;
    /*sid:45*/
    zi->next = (struct intlist_ *)((struct char_P *)0);
    /*sid:47*/
    if (r == (struct char_P *)0) { /*sid:48*/ r = zi; /*sid:49*/ z = zi; }
    else {
      /*sid:50*/
      z->next = zi;
      /*sid:51*/
      z = (struct intlist_ *)((struct char_P *)0);
      /*sid:52*/
      z = zi;
    }
    /*sid:53*/
    zi = (struct intlist_ *)((struct char_P *)0);
    /*sid:54*/
    zi = li->next;
    /*sid:55*/
    li = (struct intlist_ *)((struct char_P *)0);
    /*sid:56*/
    li = zi;
    /*sid:57*/
    zi = (struct intlist_ *)((struct char_P *)0);
  }
  /*sid:58*/
  li = y;
  /*sid:59*/
  while (li != (struct char_P *)0) {
    /*sid:63*/
    zi = (intlist )malloc(sizeof(struct intlist_ ));
    /*sid:64*/
    zi->data = li->data;
    /*sid:65*/
    zi->next = (struct intlist_ *)((struct char_P *)0);
    /*sid:67*/
    if (r == (struct char_P *)0) { /*sid:68*/ r = zi; /*sid:69*/ z = zi; }
    else {
      /*sid:70*/
      z->next = zi;
      /*sid:71*/
      z = (struct intlist_ *)((struct char_P *)0);
      /*sid:72*/
      z = zi;
    }
    /*sid:73*/
    zi = (struct intlist_ *)((struct char_P *)0);
    /*sid:74*/
    zi = li->next;
    /*sid:75*/
    li = (struct intlist_ *)((struct char_P *)0);
    /*sid:76*/
    li = zi;
    /*sid:77*/
    zi = (struct intlist_ *)((struct char_P *)0);
  }
  /*sid:78*/
  z = (struct intlist_ *)((struct char_P *)0);
  /*sid:79*/
  return (r);
}

/*@ requires //id:134
             acyclic{Here}(x_0);
    behavior default:
        */
void fold_split(intlist x_0 , int v , struct struct_intlist__xP *l ,
                struct struct_intlist__xP *u ) 
{
  intlist xi ;
  intlist y_0 ;
  intlist tmp_1_0 ;
  /*sid:80*/
  { /*undefined sequence*/ 
    /*sid:81*/
    tmp_1_0 = (struct intlist_ *)((struct char_P *)0);
    /*effects: tmp_1_0 <- */
    /*sid:82*/
    y_0 = tmp_1_0;
    /*effects: y_0 <- */
    /*sid:83*/
    xi = y_0;
    /*effects: xi <- */
  }
  /*sid:84*/
  xi = x_0;
  /*sid:85*/
  l->struct_intlist__xM = (struct intlist_ *)((struct char_P *)0);
  /*sid:86*/
  u->struct_intlist__xM = (struct intlist_ *)((struct char_P *)0);
  /*sid:87*/
  while (xi != (struct char_P *)0) {
    /*sid:91*/
    y_0 = (intlist )malloc(sizeof(struct intlist_ ));
    /*sid:92*/
    y_0->data = xi->data;
    /*sid:93*/
    y_0->next = (struct intlist_ *)((struct char_P *)0);
    /*sid:94*/
    tmp_1_0 = xi->next;
    /*sid:95*/
    xi = (struct intlist_ *)((struct char_P *)0);
    /*sid:96*/
    xi = tmp_1_0;
    /*sid:97*/
    tmp_1_0 = (struct intlist_ *)((struct char_P *)0);
    /*sid:99*/
    if (y_0->data <= v) {
      /*sid:100*/
      y_0->next = l->struct_intlist__xM;
      /*sid:101*/
      l->struct_intlist__xM = (struct intlist_ *)((struct char_P *)0);
      /*sid:102*/
      l->struct_intlist__xM = y_0;
    }
    else {
      /*sid:103*/
      y_0->next = u->struct_intlist__xM;
      /*sid:104*/
      u->struct_intlist__xM = (struct intlist_ *)((struct char_P *)0);
      /*sid:105*/
      u->struct_intlist__xM = y_0;
    }
    /*sid:106*/
    y_0 = (struct intlist_ *)((struct char_P *)0);
  }
  /*sid:134*/
  return;
}

/*@ requires //id:67
             acyclic{Here}(x_1);
    behavior default:
        */
intlist fold_clone(intlist x_1 ) 
{
  intlist xi_0 ;
  intlist y_1 ;
  intlist yi ;
  intlist z_0 ;
  /*sid:108*/
  { /*undefined sequence*/ 
    /*sid:109*/
    z_0 = (struct intlist_ *)((struct char_P *)0);
    /*effects: z_0 <- */
    /*sid:110*/
    yi = z_0;
    /*effects: yi <- */
    /*sid:111*/
    y_1 = yi;
    /*effects: y_1 <- */
    /*sid:112*/
    xi_0 = y_1;
    /*effects: xi_0 <- */
  }
  /*sid:113*/
  xi_0 = x_1;
  /*sid:114*/
  while (xi_0 != (struct char_P *)0) {
    /*sid:118*/
    z_0 = (intlist )malloc(sizeof(struct intlist_ ));
    /*sid:119*/
    z_0->data = xi_0->data;
    /*sid:120*/
    z_0->next = (struct intlist_ *)((struct char_P *)0);
    /*sid:122*/
    if (y_1 == (struct char_P *)0) { /*sid:123*/ y_1 = z_0; }
    else { /*sid:124*/ yi->next = z_0; }
    /*sid:125*/
    yi = (struct intlist_ *)((struct char_P *)0);
    /*sid:126*/
    yi = z_0;
    /*sid:127*/
    z_0 = (struct intlist_ *)((struct char_P *)0);
    /*sid:128*/
    z_0 = xi_0->next;
    /*sid:129*/
    xi_0 = (struct intlist_ *)((struct char_P *)0);
    /*sid:130*/
    xi_0 = z_0;
    /*sid:131*/
    z_0 = (struct intlist_ *)((struct char_P *)0);
  }
  /*sid:132*/
  yi = (struct intlist_ *)((struct char_P *)0);
  /*sid:133*/
  return (y_1);
}


