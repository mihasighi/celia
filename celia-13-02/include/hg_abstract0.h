/* ************************************************************************* */
/* hg_abstract0.h: generic operations on heap graph abstract values */
/* ************************************************************************* */

/* This file is part of the SHAD Library, released under LGPL license.  Please
   read the COPYING file packaged in the distribution */

#ifndef _HG_ABSTRACT0_H_
#define _HG_ABSTRACT0_H_

#include "ap_dimension.h"
#include "sh_result.h"
#include "hg_manager.h"
#include "sh_expr0.h"

/* *INDENT-OFF* */
#ifdef __cplusplus
extern "C" {
#endif
    /* *INDENT-ON* */

    /* Generic type for nodes */
    typedef size_t node_t;

    /* Generic abstract value at level 0 */
    typedef struct hg_abstract0_t {
        void* value; /* Abstract value of the underlying library */
        hg_manager_t* man; /* Used to identify the effective type of value */
    } hg_abstract0_t;

    typedef struct hg_abstract0_array_t {
        hg_abstract0_t *p; /* Array of abstract values */
        size_t size; /* Size of the array */
    } hg_abstract0_array_t;

    /* Arrays of dimensions used in folding simple nodes */
    typedef struct {
        ap_dim_t *p;
        size_t size;
    } ap_dim_array_t;

    typedef struct {
        ap_dim_array_t *p;
        size_t size;
    } ap_dim_array2_t;

    /* ********************************************************************** */
    /* I. General management */
    /* ********************************************************************** */

    /* ============================================================ */
    /* I.1 Memory */
    /* ============================================================ */

    hg_abstract0_t* hg_abstract0_copy(hg_manager_t* man, hg_abstract0_t* a,
            bool instore);
    /* Return a copy of an abstract value:
       - if instore then store the value,
       - else returns a copy such that destructive update does
         not affect the initial value. */

    void hg_abstract0_free(hg_manager_t* man, hg_abstract0_t* a,
            bool instore);
    /* Free the memory used by the abstract value:
       - if not(instore) then free the memory
       - else decrement de counter of usages.
     */

    size_t hg_abstract0_size(hg_manager_t* man, hg_abstract0_t* a);
    /* Return the number of nodes (inluding NULL) of an abstract value */


    /* ============================================================ */
    /* I.2 Control of internal representation */
    /* ============================================================ */

    hg_abstract0_t*
    hg_abstract0_add_edge(hg_manager_t* man, hg_abstract0_t* a,
            node_t nsrc, size_t field, node_t ndst,
            ap_dimperm_t* perm);
    /* Return a copy of a where the edge (nsrc,field,ndst) s added,
       if possible (i.e., nsrc,field not defined or NULL).
       The permutation of nodes generated by this operation is in perm
       (of size a->size).
     */

    hg_abstract0_t*
    hg_abstract0_add_node(hg_manager_t* man, hg_abstract0_t* a,
            ap_dim_t v, size_t vfield,
            size_t efield, node_t ndst,
            node_t* nnew,
            ap_dimperm_t* perm);
    /* Return a copy of a where is added a node nnew labeled by
       (resp. reachable from) v if vfield=0 (resp. by an edge labeled by
       vfield > 0). The successor of nnew by an edge labeled by efield is ndst.
       The permutation of nodes generated by this operation is in perm
       (of size a->size).
     */

    hg_abstract0_t*
    hg_abstract0_add_label(hg_manager_t* man, hg_abstract0_t* a,
            node_t n, ap_dim_t v,
            ap_dimperm_t* perm);
    /* Return a copy of a where the node n is labeled by v.
       The permutation of nodes generated by this operation is in perm
       (of size a->size).
     */

    hg_abstract0_t*
    hg_abstract0_expand_edge(hg_manager_t* man, hg_abstract0_t* a,
            node_t nsrc, ap_dim_t v, size_t field,
            node_t* nnew,
            ap_dimperm_t* perm);
    /* Return a copy of a where the super-edge starting from nsrc is split
       by introducing a new node nnew to which the node labeled by v
       (may be AP_DIM_MAX, i.e., none) points by an edge labeled by
       field (may be 0, i.e., v directly labels nnew).
       The permutation of nodes generated by this operation is in perm
       (of size a->size+1, perm->dim[a->size]==*nnew).
     */

    size_t
    hg_abstract0_get_edge(hg_manager_t* man, hg_abstract0_t* a,
            node_t nsrc, size_t field);
    /* Return the successor of nsrc by the edge labeled by field in a. */

    node_t
    hg_abstract0_get_null(hg_manager_t* man, hg_abstract0_t* a);
    /* Return the node representing NULL. */

    node_t*
    hg_abstract0_get_nodes(hg_manager_t* man, hg_abstract0_t* a);
    /* Return an array of size a->ptrdim mapping each pointer var v to
       the node it labels. */


    /* ============================================================ */
    /* I.3 Printing */
    /* ============================================================ */

    void hg_abstract0_fprint(FILE* stream,
            hg_manager_t* man, hg_abstract0_t* a, char** name_of_dim);
    /* Print the abstract value in a pretty way, using function
       name_of_dim to name dimensions */

    void hg_abstract0_fprintdiff(FILE* stream,
            hg_manager_t* man,
            hg_abstract0_t* a1, hg_abstract0_t* a2,
            char** name_of_dim);
    /* Print the difference between a1 (old value) and a2 (new value),
       using function name_of_dim to name dimensions.
       The meaning of difference is library dependent. */

    void hg_abstract0_fdump(FILE* stream, hg_manager_t* man, hg_abstract0_t* a);
    /* Dump the internal representation of an abstract value,
       for debugging purposes */

    /* ============================================================ */
    /* I.4 Serialization */
    /* ============================================================ */

    ap_membuf_t hg_abstract0_serialize_raw(hg_manager_t* man, hg_abstract0_t* a);
    /* Allocate a memory buffer (with malloc), output the abstract value in raw
       binary format to it and return a pointer on the memory buffer and the size
       of bytes written.  It is the user responsibility to free the memory
       afterwards (with free). */

    hg_abstract0_t* hg_abstract0_deserialize_raw(hg_manager_t* man, void* ptr,
            size_t* size);
    /* Return the abstract value read in raw binary format from the input stream
       and store in size the number of bytes read */


    /* ********************************************************************** */
    /* II. Constructor, accessors, tests and property extraction */
    /* ********************************************************************** */

    /* ============================================================ */
    /* II.1 Basic constructors */
    /* ============================================================ */

    /* We assume that dimensions [0..intdim-1] correspond to integer variables, and
       dimensions [intdim..intdim+ptrdim-1] to pointer variables */

    hg_abstract0_t* hg_abstract0_bottom(hg_manager_t* man,
            size_t intdim, size_t ptrdim);
    /* Create a bottom (empty) value */

    hg_abstract0_t* hg_abstract0_top(hg_manager_t* man,
            size_t intdim, size_t ptrdim);
    /* Create a top (universe) value */

    /* ============================================================ */
    /* II.2 Accessors */
    /* ============================================================ */

    ap_dimension_t hg_abstract0_dimension(hg_manager_t* man, hg_abstract0_t* a);
    /* Return the dimensionality of the abstract values */

    size_t hg_abstract0_var2node(hg_manager_t* man, hg_abstract0_t* a,
            ap_dim_t v);

    size_t* hg_abstract0_get_var2node(hg_manager_t* man, hg_abstract0_t* a);

    /* ============================================================ */
    /* II.3 Tests */
    /* ============================================================ */

    /* In abstract tests,

       - true means that the predicate is certainly true.

       - false means by default don't know (an exception has occurred, or the exact
         computation was considered too expensive to be performed).

         However, if the flag exact in the manager is true, then false means really
         that the predicate is false.
     */

    bool hg_abstract0_is_bottom(hg_manager_t* man, hg_abstract0_t* a);
    bool hg_abstract0_is_top(hg_manager_t* man, hg_abstract0_t* a);


    bool hg_abstract0_is_leq(hg_manager_t* man,
            hg_abstract0_t* a1, hg_abstract0_t* a2);
    /* inclusion check, i.e., a1 is a subgraph of a2, some variables in
       a1 may not be NULL in a2.
     */
    bool hg_abstract0_is_eq(hg_manager_t* man,
            hg_abstract0_t* a1, hg_abstract0_t* a2);
    /* equality check, i.e., graph isomorphism */

    bool hg_abstract0_is_dimension_unconstrained(hg_manager_t* man,
            hg_abstract0_t* a, ap_dim_t v);
    /* is the pointer v unconstrained in the abstract value? (i.e., NULL) */

    bool hg_abstract0_is_reachable(hg_manager_t* man, hg_abstract0_t* a,
            size_t nsrc, size_t field, size_t ndst);
    /* does the node ndst is reachable from nsrc using edge in field? */

    bool hg_abstract0_sat_pcons(hg_manager_t* man, hg_abstract0_t* a,
            sh_pcons0_t* pcons);
    /* does the abstract value a satisfy the constraint pcons? */

    /* ============================================================ */
    /* II.4 Extraction of properties */
    /* ============================================================ */

    sh_pcons0_array_t hg_abstract0_to_pcons_array(hg_manager_t* man, hg_abstract0_t* a);
    /* Converts an abstract value to a pointer constraint
       (conjunction of graph formula in SL3).
     */

    /* ********************************************************************** */
    /* III. Operations */
    /* ********************************************************************** */

    /* ============================================================ */
    /* III.1 Meet and Join */
    /* ============================================================ */

    hg_abstract0_t* hg_abstract0_meet(hg_manager_t* man,
            bool destructive, hg_abstract0_t* a1, hg_abstract0_t* a2);

    hg_abstract0_t* hg_abstract0_join(hg_manager_t* man,
            bool destructive, hg_abstract0_t* a1, hg_abstract0_t* a2);
    /* Meet and Join of 2 abstract values */


    /* ============================================================ */
    /* III.2 Transfer function: Condition, Assignment, and Substitutions */
    /* ============================================================ */

    hg_abstract0_t*
    hg_abstract0_meet_pcons_array(hg_manager_t* man,
            bool destructive, hg_abstract0_t* a, sh_pcons0_array_t* array);
    /* Meet of an abstract value with a set of constraints */

    hg_abstract0_t*
    hg_abstract0_assign(hg_manager_t* man,
            bool destructive,
            hg_abstract0_t* a,
            sh_passign0_t* op,
            size_t length,
            node_t* split_n, int* split_fld,
            node_t* new_n, int* new_fld,
            ap_dimperm_t * perm, ap_dim_array2_t * anon,
            hg_abstract0_t* dest);
    hg_abstract0_t* /* TODO */
    hg_abstract0_substitute(hg_manager_t* man,
            bool destructive,
            hg_abstract0_t* a,
            sh_passign0_t* op,
            size_t length,
            node_t* split_dim, int* split_fld,
            node_t* new_dim, int* new_fld,
            ap_dimperm_t * perm, ap_dim_array2_t * anon,
            hg_abstract0_t* dest);
    /* Assignment and Substitution of a pointer or pointer field by
       by a pointer expressions in abstract value a.
       dest is an optional argument. If not NULL, semantically speaking,
       the result of the transformation is intersected with dest. This is
       useful for precise backward transformations. */

    /* ============================================================ */
    /* III.3 Projections */
    /* ============================================================ */

    hg_abstract0_t*
    hg_abstract0_substitute_dimensions(hg_manager_t* man,
            hg_abstract0_t* a,
            ap_dim_t* tdim, ap_dim_t* tnew, size_t size,
            ap_dimperm_t* perm);
    /* Special projection used in procedure return:
       - all variables pointing to the same nodes that tdim point now to
         the nodes of tnew
       - all nodes having as successor a node pointed by tdim points to
         the correspoding node of tnew
       The operation generates a permutation of nodes of a in perm
       (garbage nodes mapped to 0).
       The operation is desctructive for the input value.
     */

    hg_abstract0_t*
    hg_abstract0_unify(hg_manager_t* man,
            hg_abstract0_t* a1, hg_abstract0_t* a2,
            ap_dimperm_t* perm1, ap_dimperm_t* perm2);
    /* Special operation used in procedure return:
       put together graphs a1 and a2 (which have the same dimensions) and
       unify nodes labeled with the same (not null) pointer variables in both
       graphs. The result is the new graph.
       The operation generates a permutation of nodes (a1->size resp. a2->size)
       for each graph.
       The operation is destructive for both input values.
     */

    /* ============================================================ */
    /* III.4 Change and permutation of dimensions */
    /* ============================================================ */

    hg_abstract0_t*
    hg_abstract0_add_dimensions(hg_manager_t* man,
            bool destructive,
            hg_abstract0_t* a, ap_dimchange_t* dimchange,
            bool project);
    hg_abstract0_t*
    hg_abstract0_remove_dimensions(hg_manager_t* man,
            bool destructive,
            hg_abstract0_t* a, ap_dimchange_t* dimchange);
    hg_abstract0_t*
    hg_abstract0_permute_dimensions(hg_manager_t* man,
            bool destructive,
            hg_abstract0_t* a, ap_dimperm_t* permin, ap_dimperm_t* permout);
    /* Size of the permutation is supposed to be equal to
       the dimension of the abstract value */

    /* ============================================================ */
    /* III.5 Closure operation */
    /* ============================================================ */

    hg_abstract0_t*
    hg_abstract0_closure(hg_manager_t* man,
            hg_abstract0_t* a,
            ap_dimperm_t* perm, ap_dim_array2_t* anon,
            bool cutpoint);
    /* Returns the closure of graph with garbage and anonymous.
       The permutation of nodes is in perm (of a->size), where
       garbage and anonymous nodes are mapped to 0.
       The anonymous nodes are returned, with their folding (cut point) node
       in anon (bidimensional array); nodes in each aeeay shall be sorted.
     */

    bool hg_abstract0_is_closed(hg_manager_t* man, hg_abstract0_t* a);
    /* Quick check if anonymous or garbage nodes are present in a. */


    /* ********************************************************************** */
    /* IV. Functions offered by the SHAD interface */
    /* ********************************************************************** */

    /* These functions do not correspond to functions in the underlying library. */

    static inline
    hg_manager_t* hg_abstract0_manager(hg_abstract0_t* a) {
        return a->man;
    }
    /* Return a reference to the manager contained in the abstract value.
       The reference should not be freed */


    /* ********************************************************************** */
    /* Internal functions */
    /* ********************************************************************** */

    /* factorize the check and the call for the functions above */
    hg_abstract0_t*
    hg_abstract0_meetjoin(hg_funid_t funid,
            /* either meet or join */
            hg_manager_t* man, bool destructive,
            hg_abstract0_t* a1, hg_abstract0_t* a2);

    hg_abstract0_t*
    hg_abstract0_asssub_pexpr(hg_funid_t funid,
            /* either assign or substitute */
            hg_manager_t* man,
            bool destructive,
            hg_abstract0_t* a,
            sh_passign0_t* op,
            hg_abstract0_t* dest);

    /* *INDENT-ON* */
#ifdef __cplusplus
}
#endif
/* *INDENT-ON* */

#endif
