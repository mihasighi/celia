(** Representing equation system *)

(* This file is part of the Interproc analyzer, released under GPL license.
   Please read the COPYING file packaged in the distribution.

   Copyright (C) Mathias Argoud, Gaël Lalire, Bertrand Jeannet 2007.
   Copyright (C) Mihaela Sighireanu 2010.
*)

open Format
open Lexing

(*  ********************************************************************* *)
(** {2 Hypergraphs *)
(*  ********************************************************************* *)
(** A control point *)
type point =
    { pos : Lexing.position;
      sid : int;
    }

(** Comparison for polymorhic sets and graphs *)
let compare_point (a:point) (b:point) =
  if ((a.pos.pos_cnum - b.pos.pos_cnum) == 0 &&
  ((a.sid - b.sid) == 0)) then 0 else 1

let equal_point (a:point) (b:point) =
  (a.pos.pos_cnum == b.pos.pos_cnum) &&
  (a.sid == b.sid)
 
let hash_point (a:point) = 
  abs (a.pos.pos_cnum + a.sid)


(** A variable in an equation = a control point *)
type vertex = point

(** A function in an equation: identified by an integer *)
type hedge = int


let vertex_dummy = { pos=Lexing.dummy_pos; sid=0 }
let hedge_dummy = -1

let compare = { 
  PSHGraph.hashv = {
    Hashhe.hash = hash_point;
    Hashhe.equal = equal_point;
  };
  PSHGraph.hashh = {
    Hashhe.hash = (fun x -> abs x);
    Hashhe.equal = (==)
  };
  PSHGraph.comparev = compare_point;
  PSHGraph.compareh = (-)
}
  
let create n info = PSHGraph.create compare n info

(*  ********************************************************************* *)
(** {2 Preprocessed information} *)
(*  ********************************************************************* *)

(** Useful information associated to a procedure *)
type procinfo = {
  pname : string;        (** Procedure name *)
  pstart: point;  (** Procedure start point *)
  pexit: point;   (** Procedure exit point *)
  pinput: Apron.Var.t array;  (** Array of input variables *)
  pinput_old: Apron.Var.t array;  (** Array of old input variables, ordered like pinput *)
  pinput_ini: Apron.Var.t array;  (** Array of initial input ptr variables *)
  poutput: Apron.Var.t array; (** Array of output variables *)
  plocal: Apron.Var.t array;  (** Array of other variables *)
  penv: Apron.Environment.t;   (** Environment of the procedure *)
  pinput_tmp: Apron.Var.t array;  (** Array of renamed input ptr variables *)
  poutput_tmp: Apron.Var.t array; (** Array of renamed output variables *)
  prequires: Apron.Tcons1.earray; (** Requirements for this procedure *)
  pensures: Apron.Tcons1.earray;  (** Postconditions for this procedure *)
}

(** Useful information for the program *)
type info = {
  procinfo : (string, procinfo) Hashhe.t;
    (** Hashtable [procedure name -> procinfo].
        Main procedure has empty name *)
  callret : (point,point) DHashhe.t;
    (** Two-way association call points/return points generated by procedure
      calls. *)
  pointenv : (point,Apron.Environment.t) Hashhe.t;
    (** Hashtable [point -> environment of the enclosing procedure]. *)
  mutable counter : int;
    (** Last free hyperedge identifier (used by [add_equation]). *)
}

(*  ********************************************************************* *)
(** {2 Equation system} *)
(*  ********************************************************************* *)

(** A variable in an equation = a control point *)
type var = point

(** Information associated to hyperedges/functions used in equations *)
type transfer =
  | Lassign of Apron.Var.t * Apron.Linexpr1.t
      (** Assignement by a linear expression *)
  | Tassign of Apron.Var.t * Apron.Texpr1.t
      (** Assignement by a tree expression *)
  | Condition of Apron.Tcons1.t Boolexpr.t
      (** Filtering of a predicate by a Boolean expression *)
  | Call of procinfo * procinfo * (*Apron.Texpr1.t*) (Apron.Var.t array) * (Apron.Var.t array)
      (** Procedure call, of the form (followed by Start)
	[Call(callerinfo,calleeinfo,actual input parameters,actual output parameters)] *)
  | SCall of procinfo * procinfo * (Apron.Var.t array) * (Apron.Var.t array)
      (** Procedure starts the call since call is not yet summarized
	[SCall(callerinfo,calleeinfo,actual input parameters,actual output parameters)] *)
  | SReturn of procinfo * procinfo * (Apron.Var.t array) * (Apron.Var.t array)
      (** Procedure return with the summarized information
	[SReturn(callerinfo,calleeinfo,actual input parameters,actual output parameters)] *)
  | Return of procinfo * procinfo * (*Apron.Texpr1.t*) (Apron.Var.t array) * (Apron.Var.t array)
      (** Procedure return, of the form
	[Return(callerinfo,calleeinfo,actual input parameters,actual output parameters)] *)


(** Equation system, represented by a graph, where vertex identifiers are
control point, and hyperedge identifiers are integers, with which are
associated objects of type [transfer]. Global information associated with the
graph is of type [info]. *)
type graph = (vertex,hedge,unit,transfer,info) PSHGraph.t

(*  ********************************************************************* *)
(** {2 Functions} *)
(*  ********************************************************************* *)

(** Adding an equation *)
let add_equation (graph:graph) (torg:var array) (transfer:transfer) (dest:var)
  : 
  unit

  =
  Array.iter
    (begin fun var ->
      if not (PSHGraph.is_vertex graph var) then PSHGraph.add_vertex graph var ()
    end)
    torg
  ;
  if not (PSHGraph.is_vertex graph dest) then PSHGraph.add_vertex graph dest ();
  if transfer<>(Condition(Boolexpr.CST(false))) then begin
    let info = PSHGraph.info graph in
    PSHGraph.add_hedge graph info.counter transfer ~pred:torg ~succ:[|dest|];
    info.counter <- info.counter + 1;
  end;
  ()

(*  ===================================================================== *)
(** {3 Printing functions} *)
(*  ===================================================================== *)

let print_point fmt (p:point) =
  fprintf fmt "%s:(%d,%d)" 
    p.pos.Lexing.pos_fname 
    p.pos.Lexing.pos_lnum
    p.sid

let print_tvar fmt (tvar:Apron.Var.t array) =
  Pp.print_list_delim
    (fun fmt () -> fprintf fmt "[|@[<hov>") (* start *)
    (fun fmt () -> fprintf fmt "@]|]") (* stop *)
    (fun fmt () -> fprintf fmt ";@ ") (* sep *)
    Apron.Var.print
    fmt (Array.to_list tvar)

let print_texpr fmt (texp:Apron.Texpr1.t array) =
  Pp.print_list_delim
    (fun fmt () -> fprintf fmt "[|@[<hov>") (* start *)
    (fun fmt () -> fprintf fmt "@]|]") (* stop *)
    (fun fmt () -> fprintf fmt ";@ ") (* sep *)
    Apron.Texpr1.print
    fmt (Array.to_list texp)

let print_procinfo fmt procinfo =
  fprintf fmt "{ @[<v>pstart = %a;@ pexit = %a;@ pinput = %a;@ pinput_old = %a; pinput_ini = %a;@ poutput = %a;@ plocal = %a;@ penv = %a;@ pinput_tmp = %a;@ poutput_tmp = %a;@ prequires = %a;@ pensures = %a@] }"
    print_point procinfo.pstart
    print_point procinfo.pexit
    print_tvar procinfo.pinput
    print_tvar procinfo.pinput_old
    print_tvar procinfo.pinput_ini
    print_tvar procinfo.poutput
    print_tvar procinfo.plocal
    (fun fmt e -> Apron.Environment.print fmt e) procinfo.penv
    print_tvar procinfo.pinput_tmp
    print_tvar procinfo.poutput_tmp
    (fun fmt c ->
      Apron.Tcons1.array_print 
	~first:"[|@[<hov>" ~sep:";@ " ~last:"@]|]"
	fmt c) procinfo.prequires
    (fun fmt c ->
      Apron.Tcons1.array_print 
	~first:"[|@[<hov>" ~sep:";@ " ~last:"@]|]"
	fmt c) procinfo.pensures

let print_info fmt info =
  fprintf fmt "{ @[<v>procinfo = %a;@ callret = %a;@ pointenv = %a;@ counter = %i;@] }"
    (Hashhe.print pp_print_string print_procinfo) info.procinfo
    (DHashhe.print print_point print_point) info.callret
    (Hashhe.print print_point Apron.Environment.print) info.pointenv
    info.counter

let print_transfer fmt transfer = match transfer with
  | Lassign _ -> failwith ""
  | Tassign(v,e) -> 
      fprintf fmt "%a = %a"
      Apron.Var.print v
      Apron.Texpr1.print e
  | Condition(bexpr) ->
      fprintf fmt "IF %a"
      (Boolexpr.print Apron.Tcons1.print) bexpr
  | Call(callerinfo,calleeinfo,pin,pout) ->
      fprintf fmt "CALL %a = %s(%a)"
      print_tvar pout
      calleeinfo.pname
      print_tvar pin  
  | Return(callerinfo,calleeinfo,pin,pout) ->
      fprintf fmt "RETURN %a = %s(%a)"
      print_tvar pout
      calleeinfo.pname
      print_tvar pin
  | SCall(callerinfo,calleeinfo,pin,pout) ->
      fprintf fmt "sCALL %a = %s(%a)"
      print_tvar pout
      calleeinfo.pname
      print_tvar pin 
  | SReturn(callerinfo,calleeinfo,pin,pout) ->
      fprintf fmt "sRETURN %a = %s(%a)"
      print_tvar pout
      calleeinfo.pname
      print_tvar pin


let print_graph fmt graph = 
  PSHGraph.print
(* dot 
    ~style="size=\"7.5,10\";center=true;ranksep=0.16;nodesep=0.2;"
    ~titlestyle="shape=ellipse,style=bold,style=filled,fontsize=20"
    ~vertexstyle="shape=box,fontsize=12"
    ~hedgestyle="shape=ellipse,fontsize=12"
    ~fvertexstyle=(fun v -> "\"%s\"")
    ~fhedgestyle=(fun h -> "\"%s\"")
    ~title="icfgraph"
*)
    print_point  (* vertex *)
    (fun fmt i -> Format.fprintf fmt "%d" i) (* hedge *)
    (fun fmt () -> ()) (* unit *)
    print_transfer
    print_info
    fmt graph
